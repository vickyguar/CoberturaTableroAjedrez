///////////////////////////////////////////////////////////
//  Tablero.cs
//  Implementation of the Class Tablero
//  Generated by Enterprise Architect
//  Created on:      06-oct.-2021 08:09:08
//  Original author: vguar
///////////////////////////////////////////////////////////

using System;
using System.Collections.Generic;
using System.Text;
using System.IO;

public enum Color : int
{
    BLANCO = 0,
    NEGRO

}//end ColorAlfil

public class Tablero
{

    //private static uint ContSoluciones = 0; //Inicializamos en cero el contador static
    //private ushort ID;
    public Casilla[,] Matriz = new Casilla[8, 8]; //Acceso publico, para que las fichas se puedan posicionar y atacar
    private Stack<Ficha>PilaPosicionadas = new Stack<Ficha>(8);


    public Tablero()
    {
        //ID = Convert.ToUInt16(ContSoluciones);

        //Creamos la matriz de Casillas (tiempo n^2, fors anidados)
        for (uint i = 0; i < 8; ++i)
        {
            for (uint j = 0; j < 8; ++j)
            {
                Matriz[i, j] = new Casilla(i, j);
            }
        }

        //TODO: Se inicializa la pila?
    }

    ~Tablero()
    {

    }

    #region GENERADORES SOLUCIONES
    public Tablero Espejar()
    {
        Tablero Espejado = this; //copia del tablero original
        foreach (Ficha fichita in Espejado.PilaPosicionadas)
        {
            switch (fichita.GetPos().GetColumna())
            {
                case 0:
                    fichita.GetPos().SetColumna(7); break;
                case 1:
                    fichita.GetPos().SetColumna(6); break;
                case 2:
                    fichita.GetPos().SetColumna(5); break;
                case 3:
                    fichita.GetPos().SetColumna(4); break;
                case 4:
                    fichita.GetPos().SetColumna(3); break;
                case 5:
                    fichita.GetPos().SetColumna(2); break;
                case 6:
                    fichita.GetPos().SetColumna(1); break;
                case 7:
                    fichita.GetPos().SetColumna(0); break;
            }
        }

        return Espejado;
    }
    public Tablero Rotar90()
    {
        /*
         * int t;
        for (int i = 0; i < fil; i++)
        {
            t = 0;
            for (int j = fil - 1; j >= 0; j--)
            {
                mTemp[i][t] = m[j][i];
                t++;
            }
        }
        */
        return null;
    }
    #endregion

    public bool FiltrarFatales() //Si devuelve true, en el main lo agrego a la lista de fatales.
    {
        //La idea es ir sacando las fichas y ver en donde estan
        /* TableroFisico.FiltrarFatales()  -> Este tablero fisico no esta "pintado", el que está pintado es el de Ataque
         * Podríamos hacer una copia de este tablero físico, y llamarlo Tablero filtrado, y pintar a tablero filtrado
         */
        Tablero Filtrado = this; //es una copia del tablero fisico

        for (uint i = 0; i < 8; ++i) //recorremos la pila de fichas en el tablero de copia
            Filtrado.PilaPosicionadas.Pop().Atacar(Filtrado, true); //"pintar casilleros" de forma fatal (true)
        return (Filtrado.VerificarSolucion()) ? true : false; //si es una solución fatal, devulve true y sino devuelve false
    }

    public void Imprimir()
    {
        //Boton: print
    }

    public void Limpiar()
    {
        //Boton: clear
    }

    public bool VerificarSolucion()
    {
        for (int i = 0; i < 8; i++)
        {
            for (int j = 0; j < 8; j++)
            {
                if (!Matriz[i, j].GetAtacada())
                    return false;
            }
        }
        return true;
    }

    /// 
    /// <param name="Ficha"></param>
    /// <param name="ListaPos"></param>
    public void Posicionar(Ficha Fichita, Tablero Ataque, List<Casilla> SubLista, bool Remove = true) //Se administra desde el main
    {
        //Variable
        Random r = new Random();
        int index = 0;

        index = Convert.ToInt32(r.Next(SubLista.Count)); //Elegimos un índice random de la SubLista 

        if (Fichita.GetName() == "Alfil2")
        {
            Ficha FichaAux = PilaPosicionadas.Peek();
            while (Fichita.GetPos().GetColor() == FichaAux.GetPos().GetColor()) //Mientras los dos alfiles sean del mismo color
                Posicionar(Fichita, Ataque, SubLista);
        }
       
        Fichita.SetPos(SubLista[index]); //La ficha tiene como Posicion ese nuevo ítem (esa casilla)

        Fichita.Atacar(Ataque); //Es la funcion que "pinta" --> OJO porque no es la filtrada

        PilaPosicionadas.Push(Fichita);

        if(Remove)
            SubLista.RemoveAt(index); //Sacamos de la lista al elemento ocupado, para que otros no lo puedan ocupar.

        #region IDEA PREVIA
        //    //1 REINA
        //    if (Fichita.GetName() == "Reina")
        //    {
        //        index = Convert.ToInt32(r.Next(Cuadrado1.Count)); //Elegimos un índice random de la SubLista "Cuadrado1"

        //        Fichita.SetPos(Cuadrado1[index]); //La ficha tiene como Posicion ese nuevo ítem (esa casilla)

        //        //while(Fichita.GetPos().GetOcupada()) //Mientras que   --> PENSAMOS QUE ES REDUNDANTE.
        //        //    Posicionar(Fichita);                                  Si lo estamos sacando de la lista, entonces no tendría por qué elegir el mismo elemento

        //        Fichita.Atacar(Ataque); //Es la funcion que "pinta" --> OJO porque no es la filtrada

        //        PilaPosicionadas.Push(Fichita);

        //        Cuadrado1.RemoveAt(index); //Sacamos de la lista al elemnto ocupado, para que otros no lo puedan ocupar.
        //    }

        //    //2 ALFIL1
        //    else if (Fichita.GetName() == "Alfil1")
        //    {
        //        index = Convert.ToInt32(r.Next(Cuadrado1.Count)); //Elegimos un índice random de la SubLista "Cuadrado1"

        //        Fichita.SetPos(Cuadrado1[index]); //La ficha tiene como Posicion ese nuevo ítem (esa casilla)

        //        Fichita.Atacar(Ataque); //Es la funcion que "pinta" --> OJO porque no es la filtrada

        //        PilaPosicionadas.Push(Fichita);

        //        Cuadrado1.RemoveAt(index); //Sacamos de la lista al elemnto ocupado, para que otros no lo puedan ocupar.
        //                                   //TODO: wtf es por copia o puntero?? si borramos se nos borra todo??
        //    }

        //    //3 ALFIL2
        //    else if (Fichita.GetName() == "Alfil2")
        //    {
        //        Ficha FichaAux = PilaPosicionadas.Peek();

        //        index = Convert.ToInt32(r.Next(Cuadrado2.Count)); //Elegimos un índice random de la SubLista "Cuadrado1"

        //        while (Fichita.GetPos().GetColor() == FichaAux.GetPos().GetColor()) //Mientras los dos alfiles sean del mismo color
        //            Posicionar(Fichita, Ataque);

        //        Fichita.SetPos(Cuadrado2[index]); //La ficha tiene como Posicion ese nuevo ítem (esa casilla)

        //        Fichita.Atacar(Ataque); //Es la funcion que "pinta" --> OJO porque no es la filtrada

        //        PilaPosicionadas.Push(Fichita);

        //        Cuadrado2.RemoveAt(index); //Sacamos de la lista al elemnto ocupado, para que otros no lo puedan ocupar.
        //    }

        //    //4 CABALLO 1
        //    else if (Fichita.GetName() == "Cabllo1")
        //    {
        //        index = Convert.ToInt32(r.Next(Cuadrado2.Count)); //Elegimos un índice random de la SubLista "Cuadrado1"

        //        Fichita.SetPos(Cuadrado2[index]); //La ficha tiene como Posicion ese nuevo ítem (esa casilla)

        //        Fichita.Atacar(Ataque); //Es la funcion que "pinta" --> OJO porque no es la filtrada

        //        PilaPosicionadas.Push(Fichita);

        //        Cuadrado2.RemoveAt(index); //Sacamos de la lista al elemnto ocupado, para que otros no lo puedan ocupar.
        //                                   
        //    }

        //    //5 REY
        //    else if (Fichita.GetName() == "Rey")
        //    {
        //        index = Convert.ToInt32(r.Next(Cuadrado3.Count)); //Elegimos un índice random de la SubLista "Cuadrado1"

        //        Fichita.SetPos(Cuadrado3[index]); //La ficha tiene como Posicion ese nuevo ítem (esa casilla)

        //        Fichita.Atacar(Ataque); //Es la funcion que "pinta" --> OJO porque no es la filtrada

        //        PilaPosicionadas.Push(Fichita);

        //        Cuadrado3.RemoveAt(index); //Sacamos de la lista al elemnto ocupado, para que otros no lo puedan ocupar.
        //    }

        //    //6 TORRE1
        //    else if (Fichita.GetName() == "Torre1")
        //    {
        //        index = Convert.ToInt32(r.Next(Cuadrado4.Count)); //Elegimos un índice random de la SubLista "Cuadrado1"

        //        Fichita.SetPos(Cuadrado4[index]); //La ficha tiene como Posicion ese nuevo ítem (esa casilla)

        //        Fichita.Atacar(Ataque); //Es la funcion que "pinta" --> OJO porque no es la filtrada

        //        PilaPosicionadas.Push(Fichita);

        //        Cuadrado4.RemoveAt(index); //Sacamos de la lista al elemnto ocupado, para que otros no lo puedan ocupar.
        //    }

        //    //7 CABALLO2 -> NO BORRO!
        //    else if (Fichita.GetName() == "Caballo2")
        //    {
        //        index = Convert.ToInt32(r.Next(Cuadrado2.Count)); //Elegimos un índice random de la SubLista "Cuadrado2"

        //        Fichita.SetPos(Cuadrado2[index]); //La ficha tiene como Posicion ese nuevo ítem (esa casilla)

        //        Fichita.Atacar(Ataque); //Es la funcion que "pinta" --> OJO porque no es la filtrada

        //        PilaPosicionadas.Push(Fichita);

        //        // No borro, porque puede superponerse con la Torre2, que siempre es la proxima en ubicarse.
        //        //Cuadrado2.RemoveAt(index); //Sacamos de la lista al elemnto ocupado, para que otros no lo puedan ocupar.
        //    }

        //    //8 TORRE2 -> NO BORRO!
        //    else if (Fichita.GetName() == "Torre2")
        //    {
        //        Random rnd = new Random();
        //        switch (Convert.ToInt32(rnd.Next(1,4)))
        //        {
        //            case 1: index = Convert.ToInt32(r.Next(Cuadrado2.Count)); break;
        //            case 2: index = Convert.ToInt32(r.Next(Cuadrado3.Count)); break;
        //            case 3: index = Convert.ToInt32(r.Next(Cuadrado4.Count)); break;
        //        }

        //        Fichita.Atacar(Ataque); //Es la funcion que "pinta" --> OJO porque no es la filtrada

        //        PilaPosicionadas.Push(Fichita);

        //        //No borro :)
        //    }
        #endregion
    }
    //TODO: agregar funcion que intercambie torres Y CABALLOS :)
}
//end Tablero